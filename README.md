# MicroNCC

##编译和运行
* 编译
 * `make`
* 运行
 * `make run`

##项目说明

###IR的内存形式
这一块我会尽快完成，但在完成前，各位也可以进行自己模块初步的设计与构想，或者各位也可以帮忙设计，初步目标是支持到链接与静态库。

###添加新模块
####目录结构上的变化
front目录为当前我正在开发的模块，如果需要开发自己的模块，则需要先建立对应的文件夹。假设你的模块名back，那么你需要建立back文件夹，并在back下新建文件Makefile.part。Makefile.part是你的模块的生成规则，在这里我们约定你的规则应将你的模块编译连接为一个可重定向文件。
为了减少写Makefile的负担，你可以使用Makefile.build文件自动生成编译连接规则，比如你在你的back模块下的Makefile.part中添加一句`$(eval $(call make_common_rules,back,))`，这条语句会加载Makefile.build文件中的所有规则：

* 设定你的可重定向文件的目标位置为output/<你的模块名>。
* 在你的目录下查找所有的.c文件和.S文件(注意大小写)。
* 添加依赖规则，生成目标为<你的模块名>.tab.o，其依赖于你模块下所有.c文件对应的.o文件。
* 对所有的.c文件进行编译，编译输出文件放在output/<你的模块名>下。
* 将你的模块里的所有.o文件链接为一个可重定向文件。

####添加自己模块的编译规则的注意点
* 你需要在根目录的Makefile的ALL\_PARTS变量右边加上你的模块名。
* 你的目标文件应该存放在变量`<你的模块名>_PART_OBJ`中。

###库函数
####注意点
在lib目录下放着本项目所有使用到的库文件，由于本项目最终目标是运行在一个几乎全裸的机器上，所以不建议开发过程中使用除c标准库以外的库。如果你需要编写自己的库，直接在这个目录下编写即可。编写完毕需要将包含库函数声明的头文件名写在common.h的相应位置。

####已实现的库
* hash
 * 一个hash库
* vector
 * 一个动态增长的数组
* mempool
 * 这个库分段式分配内存，相较于realloc和vector会保留所有已分配元素的位置，这意味着指向这些元素的指针始终是有效的，单从这一点看，和malloc似乎没什么区别，但相较于为每一个元素malloc，用mempool可以按模块的释放内存。
* bpool
 * 这个库或许没什么用处，是我之前开发过程中设计出来应对特定情况的，它可以返回给你一个不限大小的指针，你可以在这个指针上尽情的使用内存，并只需要在使用完毕告诉这个模块你用了多少内存，这个模块会将你依旧需要的这部分内存拷贝给你。这个模块适用于目标内存大小未知，但可以确定不会无限增长的情形。

###命令行参数解析
####说明
每个模块可能或多或少需要一部分命令参数，本着让开发者专注于自己模块开发而不被琐事干扰的原则，这些琐事便由我提前代劳。这个模块我想过很多方案，最后一一否决保留了这一个方案，可能这依旧不符合你的需求/审美，不过你可以按照自己的需求更改这个模块。

####简介
命令行参数的解析遵循POSIX标准，即参数有长短名之分，对于长名有形式`--link`和`--output=a.c`，前者是纯开关，后者附带一个取值。对应于短名其形式分别为`-l`和`-o a.c`。

####使用
* 在entry/opt.h的enum结构中添加你自己的参数名
* 在entry/main.c的registered\_arguments数组中你的参数的长短名
* 使用函数get\_onoff\_from\_arguments(< your_arg>)可以查询你的参数是否被传入命令行
* 使用函数get\_value\_from\_arguments(< your_arg>)可以查询你的参数在命令行中的取值
